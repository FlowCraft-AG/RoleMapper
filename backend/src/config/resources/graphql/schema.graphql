type Query {
  # Benutzerbezogene Abfragen
  getUsers(filters: UserFilterInput): [User!]!
  getUserById(id: ID!): User
  getUserByUserId(userId: String!): User

  # Funktionsbezogene Abfragen
  getFunctionById(id: ID!): Function
  getFunctionByType(type: String!): Function
  getFunctions(filters: FunctionFilterInput): [Function!]!

  # Prozessbezogene Abfragen
  getProcessById(id: ID!): Process
  getProcessByProcessId(processId: String!): Process
  getProcesses: [Process!]!

  # Rollenbezogene Abfragen
  getRoleById(id: ID!): Role
  getRoleByRoleId(roleId: String!): Role
  getRoles: [Role!]!

  # Organisationsbezogene Abfragen
  getOrgUnitById(id: ID!): OrgUnit
  getOrgUnits(filter: OrgUnitFilterInput): [OrgUnit!]!

  # Query für die Aggregation
  getProcessRoles(processId: ID!, userId: String!): RolePayload!
}

type Function {
  functionName: String!
  users: [String!]!
  orgUnit: String!
}

type OrgUnit {
  name: String!
  parentId: ID
  supervisor: String
}

type Role {
  name: String!
  roleId: String
  query: [QueryStage!]
}

type QueryStage {
  # Die Struktur eines PipelineStage ist flexibel und hängt der query ab.
  # Hier verwenden wir ein generisches JSON-Objekt.
  key: String
  value: String
}

type Process {
  name: String!
  processId: String!
  roles: [ProcessRole!]!
}

type ProcessRole {
  roleKey: String!
  roleId: String!
}

type User {
  _id: ID!
  userId: String!
  userType: String!
  userRole: String!
  orgUnit: String!
  active: Boolean!
  student: Student
  employee: Employee
  validFrom: String!
  validUntil: String!
}

type Student {
  _id: ID!
  courseOfStudy: String!
  courseOfStudyUnique: String!
  courseOfStudyShort: String!
  courseOfStudyName: String!
  level: String!
  examRegulation: String!
}

type Employee {
  costCenter: String!
  department: String!
}

type TokenResult {
  access_token: String!
  expires_in: Int!
  refresh_token: String!
  refresh_expires_in: Int!
  id_token: String!
  scope: String!
}

type RolePayload {
  roles: [RoleResult]
}

type RoleResult {
  roleName: String! # Dynamischer Rollenname (z. B. "Antragssteller", "Rechnungsprüfung")
  users: [User!]! # Benutzer, die dieser Rolle zugeordnet sind
}


type Mutation {
  # Benutzerbezogene Mutationen
  createUser(userData: CreateUserInput!): User!
  updateUser(id: ID!, updateData: UpdateUserInput!): User
  deleteUser(id: ID!): User

  # Funktionsbezogene Mutationen
  createFunction(functionData: CreateFunctionInput!): Function!
  updateFunction(id: ID!, updateData: UpdateFunctionInput!): Function
  deleteFunction(id: ID!): Function

  # Organisationsbezogene Mutationen
  createOrgUnit(orgUnitData: CreateOrgUnitInput!): OrgUnit!
  updateOrgUnit(id: ID!, updateData: UpdateOrgUnitInput!): OrgUnit
  deleteOrgUnit(id: ID!): OrgUnit

  # Rollenbezogene Mutationen
  createRole(roleData: CreateRoleInput!): Role!
  updateRole(id: ID!, updateData: UpdateRoleInput!): Role
  deleteRole(id: ID!): Role

  # Prozessbezogene Mutationen
  createProcess(processData: CreateProcessInput!): Process!
  updateProcess(id: ID!, updateData: UpdateProcessInput!): Process
  deleteProcess(id: ID!): Process

  # Authentifizierungsbezogene Mutationen
  # Mutation, wenn z.B. der Login-Zeitpunkt im IDM-System gespeichert wird
  token(username: String!, password: String!): TokenResult
  refresh(refresh_token: String!): TokenResult
}

# Benutzerbezogene Inputs
input UserFilterInput {
  userId: String
  userType: UserType
  userRole: UserRole
  orgUnit: String
  active: Boolean
}

input CreateUserInput {
  userId: String!
  userType: UserType!
  userRole: String!
  orgUnit: String
  active: Boolean = false
  validFrom: String
  validUntil: String
}

input UpdateUserInput {
  userId: String
  userType: UserType
  userRole: String
  orgUnit: String
  active: Boolean
  validFrom: String
  validUntil: String
}

# Funktionsbezogene Inputs
input FunctionFilterInput {
  users: [String!]
  orgUnit: String
}

input CreateFunctionInput {
  functionName: String!
  users: [String!]!
  orgUnit: String!
}

input UpdateFunctionInput {
  functionName: String
  users: [String!]
  orgUnit: String
}

# Rollenbezogene Inputs
input RoleFilterInput {
  name: String
  roleId: String
}

input CreateRoleInput {
  name: String!
  roleId: String!
  query: [QueryStageInput!]
}

input UpdateRoleInput {
  name: String
  roleId: String
  query: [QueryStageInput!]
}

input QueryStageInput {
  key: String
  value: String
}

# Prozessbezogene Inputs
input CreateProcessInput {
  name: String!
  processId: String!
  roles: [ProcessRoleInput!]!
}

input UpdateProcessInput {
  name: String
  processId: String
  roles: [ProcessRoleInput!]
}

input ProcessRoleInput {
  roleKey: String!
  roleId: String!
}

# Organisationsbezogene Inputs
input OrgUnitFilterInput {
  name: String
  parentId: ID
  supervisor: String
}

input CreateOrgUnitInput {
  name: String!
  parentId: ID
  supervisor: String
}

input UpdateOrgUnitInput {
  name: String
  parent_id: ID
  supervisor: String
}

enum UserType {
  employee
  student
}

enum UserRole {
  lecturer
  professor
  academicStaff
  adminTechnicalStaff

}


scalar JSON
