type Query {
  # Benutzerbezogene Abfragen
  getUsers(filters: UserFilterInput): [User!]!
  getUserById(id: ID!): User
  getUserByUserId(userId: String!): User

  # Funktionsbezogene Abfragen
  getFunctionById(id: ID!): Function
  getFunctionByType(type: String!): Function
  getFunctions(filters: FunctionFilterInput): [Function!]!

  # Prozessbezogene Abfragen
  getProcessById(id: ID!): Process
  getProcessByProcessId(processId: String!): Process
  getProcesses: [Process!]!

  # Rollenbezogene Abfragen
  getRoleById(id: ID!): Role
  getRoleByRoleId(roleId: String!): Role
  getRoles: [Role!]!

  # Organisationsbezogene Abfragen
  getOrgUnitById(id: ID!): OrgUnit
  getOrgUnits(filter: OrgUnitFilterInput): [OrgUnit!]!

  # Query für die Aggregation
  getProcessRoles(processId: ID!, userId: String!): RolePayload!

  getData(entity: EntityType!, filters: FilterInput): [JSON!]!
  getDataDynamic(request: AggregationRequest!): [JSON!]!
}

type Function {
  functionName: String!
  users: [String!]!
  orgUnit: String!
}

type OrgUnit {
  name: String!
  parentId: ID
  supervisor: String
}

type Role {
  name: String!
  roleId: String
  query: [QueryStage!]
}

type QueryStage {
  # Die Struktur eines PipelineStage ist flexibel und hängt der query ab.
  # Hier verwenden wir ein generisches JSON-Objekt.
  key: String
  value: String
}

type Process {
  name: String!
  processId: String!
  roles: [ProcessRole!]!
}

type ProcessRole {
  roleKey: String!
  roleId: String!
}

type User {
  _id: ID!
  userId: String!
  userType: String!
  userRole: String!
  orgUnit: String!
  active: Boolean!
  student: Student
  employee: Employee
  validFrom: String!
  validUntil: String!
  functionName: String,
}

type Student {
  _id: ID!
  courseOfStudy: String!
  courseOfStudyUnique: String!
  courseOfStudyShort: String!
  courseOfStudyName: String!
  level: String!
  examRegulation: String!
}

type Employee {
  costCenter: String!
  department: String!
}

type TokenResult {
  access_token: String!
  expires_in: Int!
  refresh_token: String!
  refresh_expires_in: Int!
  id_token: String!
  scope: String!
}

type RolePayload {
  roles: [RoleResult]
}

type RoleResult {
  roleName: String! # Dynamischer Rollenname (z. B. "Antragssteller", "Rechnungsprüfung")
  users: [User!]! # Benutzer, die dieser Rolle zugeordnet sind
}


type Mutation {
  # Benutzerbezogene Mutationen
  createUser(userData: CreateUserInput!): User!
  updateUser(id: ID!, updateData: UpdateUserInput!): User
  deleteUser(id: ID!): User

  # Funktionsbezogene Mutationen
  createFunction(functionData: CreateFunctionInput!): Function!
  updateFunction(id: ID!, updateData: UpdateFunctionInput!): Function
  deleteFunction(id: ID!): Function

  # Organisationsbezogene Mutationen
  createOrgUnit(orgUnitData: CreateOrgUnitInput!): OrgUnit!
  updateOrgUnit(id: ID!, updateData: UpdateOrgUnitInput!): OrgUnit
  deleteOrgUnit(id: ID!): OrgUnit

  # Rollenbezogene Mutationen
  createRole(roleData: CreateRoleInput!): Role!
  updateRole(id: ID!, updateData: UpdateRoleInput!): Role
  deleteRole(id: ID!): Role

  # Prozessbezogene Mutationen
  createProcess(processData: CreateProcessInput!): Process!
  updateProcess(id: ID!, updateData: UpdateProcessInput!): Process
  deleteProcess(id: ID!): Process

  # Authentifizierungsbezogene Mutationen
  # Mutation, wenn z.B. der Login-Zeitpunkt im IDM-System gespeichert wird
  token(username: String!, password: String!): TokenResult
  refresh(refresh_token: String!): TokenResult

  # Zentrale Funktion zum Erstellen von Daten
  createData(request: CrudRequest!): JSON!

  # Zentrale Funktion zum Aktualisieren von Daten
  updateData(request: CrudRequest!): JSON!

  # Zentrale Funktion zum Löschen von Daten
  deleteData(request: DeleteRequest!): Boolean!
}

# Benutzerbezogene Inputs
input UserFilterInput {
  userId: String
  userType: UserType
  userRole: UserRole
  orgUnit: String
  active: Boolean
}

input CreateUserInput {
  userId: String!
  userType: UserType!
  userRole: String!
  orgUnit: String
  active: Boolean = false
  validFrom: String
  validUntil: String
}

input UpdateUserInput {
  userId: String
  userType: UserType
  userRole: String
  orgUnit: String
  active: Boolean
  validFrom: String
  validUntil: String
}

# Funktionsbezogene Inputs
input FunctionFilterInput {
  users: [String!]
  orgUnit: String
}

input CreateFunctionInput {
  functionName: String!
  users: [String!]!
  orgUnit: String!
}

input UpdateFunctionInput {
  functionName: String
  users: [String!]
  orgUnit: String
}

# Rollenbezogene Inputs
input RoleFilterInput {
  name: String
  roleId: String
}

input CreateRoleInput {
  name: String!
  roleId: String!
  query: [QueryStageInput!]
}

input UpdateRoleInput {
  name: String
  roleId: String
  query: [QueryStageInput!]
}

input QueryStageInput {
  key: String
  value: String
}

# Prozessbezogene Inputs
input CreateProcessInput {
  name: String!
  processId: String!
  roles: [ProcessRoleInput!]!
}

input UpdateProcessInput {
  name: String
  processId: String
  roles: [ProcessRoleInput!]
}

input ProcessRoleInput {
  roleKey: String!
  roleId: String!
}

# Organisationsbezogene Inputs
input OrgUnitFilterInput {
  name: String
  parentId: ID
  supervisor: String
}

input CreateOrgUnitInput {
  name: String!
  parentId: ID
  supervisor: String
}

input UpdateOrgUnitInput {
  name: String
  parent_id: ID
  supervisor: String
}

enum UserType {
  employee
  student
}

enum UserRole {
  lecturer
  professor
  academicStaff
  adminTechnicalStaff

}


# Allgemeine Eingabe für Create und Update
input CrudRequest {
  entity: EntityType!    # Ziel-Entität (z. B. USERS, FUNCTIONS, ORG_UNITS)
  data: JSON!            # Die zu erstellenden oder aktualisierenden Daten
  filter: JSON           # Filter, um die zu aktualisierenden Datensätze zu bestimmen (nur bei Update)
}

# Eingabe für Delete
input DeleteRequest {
  entity: EntityType!    # Ziel-Entität (z. B. USERS, FUNCTIONS, ORG_UNITS)
  filter: JSON!          # Filter, um die zu löschenden Datensätze zu bestimmen
}

# Mögliche Entitäten, auf die CRUD angewendet wird
enum EntityType {
  USERS
  FUNCTIONS
  PROCESSES
  ROLES
  ORG_UNITS
}

input AggregationRequest {
  rootEntity: EntityType!         # Die Haupt-Entität
  lookups: [LookupDefinition!]       # Dynamische Verknüpfungen zu anderen Entitäten
  filters: FilterInput            # Globale Filter
}

input LookupDefinition {
  from: EntityType!               # Die zu verknüpfende Entität
  localField: String!             # Feld der Haupt-Entität
  foreignField: String!           # Feld der Ziel-Entität
  as: String!                     # Alias für die verknüpften Daten
}

# Flexible Filterbedingungen
input FilterInput {
  and: [FilterInput]
  or: [FilterInput]
  not: FilterInput
  field: String          # Das zu filternde Feld
  operator: String       # Vergleichsoperator (z. B. $eq, $in, $gte, etc.)
  value: JSON            # Der Wert, mit dem verglichen wird
}

# Rückgabewert kann flexibel bleiben (JSON)
scalar JSON
